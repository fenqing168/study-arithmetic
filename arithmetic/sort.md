# 排序算法
1. 介绍
    * 排序也称之为排序算法（sort algorithm），排序是将一组数据，依指定的顺序进行排列的过程
    * 分类
        * 内部排序：指的是需要处理的所有数据都加载到内部存储器中进行排序
        * 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
    * 常见的排序算法分类：
        * 使用内存
            * 插入排序
                * 直接插入排序
                * 希尔排序
            * 选择排序
                * 简单选择排序
                * 堆排序
            * 交换排序
                * 冒泡排序
                * 快速排序
            * 归并排序
            * 基数排序
    
2. 算法时间复杂度
    * 事后统计的方法
        * 这种方法可行，但是又两个问题，一是要想对设计的算法的运行醒醒脑进行评测，需要实际运行改程序，二是所得时间的统计量依赖于计算机的硬件
    软件等环境因素，这种方式要在同一台计算机相同状态下运行，才能比较哪个算法速度更快
        
    * 事前估算的方法
        * 通过分析某个算法的时间复杂度判断哪个算法更优
    
3. 时间频度
    * 介绍：
        * 一个算法话费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，他花费的时间就多，一个算法中的语句频度
        或时间频度记为T(n),一般统计时，会忽略常数项，还可以忽略低次数，忽略系数
    
4. 时间复杂度：
    * 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),
    是的当n趋近无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称为f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))
      称之为O(f(n))为算法的渐进时间复杂度，简称时间复杂度
      
    * T(n)不同，但时间复杂度可能相同，如：T(n)=n^2+7n+6与T(n)=3n^2+2n+2他们的T(n)不同，但是时间复杂度相同，都为O(n^2)
    * 计算时间复杂度的方法
        * 用常数1代替运行时间中所有加法常量
        * 修改后的运行次数函数中，只保留最高阶项
        * 取出最高阶项的系数
    * 常见的时间复杂度
        * 常数阶O(1)
        * 对数阶O(log2n)
        * 线性阶O(n)
        * 线性对数阶O(nlog2n)
        * 平方阶(n^2)
        * 立方阶(n^3)
        * k次方阶(n^k)
        * 指数阶O(2^n)
    
5. 算法的空间复杂度
    1. 介绍：
        * 类似于时间复杂度的讨论，一个算法的空间复杂度定义为该算法锁耗费的存储空间，他也是问题规模n的函数
        * 空间复杂度是一个算法的在运行过程中临时占用存储空间大小的度量，有的算法需要占用的临时工作单元数与解决问题的规模n有关
        他随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
        * 在做算法分析时，主要讨论的是时间复杂度，从用户使用体验上看，更看重的程序执行速度，一些缓存产品，redis，memcache和算法（基数排序）本质是用空间换时间
    
6. 冒泡排序

    1. 介绍：

        冒泡排序的基本思想是，通过对待排序序列从前向后（从下表较小的元素开始），一次比较相邻的元素的值，若发现逆序交换，使其较大的元素主键从前移向后部，就像水底的气泡一样主键向上冒

        因为排序的过程中，各元素不短接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换，从而减少不必要的比较
        
    2. 规则：

        1. 一共进行数组的大小-1次大循环
        2. 每一趟排序的次数在逐渐减少
        3. 如果我们发现某糖排序中，没有发生一次交换，可以提前结束排序

    3. 代码见： cn.fenqing.arithmetic.sort.BubbleSort
    
7. 选择排序

    1. 介绍

        选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一些元素，在依规定交换位置后达到排序的目的

    2. 思想

        1. 选择排序也是一种简单的排序方法，他的基本思想是：第一次从arr[0]~arr[n-1]中取最小值，与arr[0]交换,第二次从arr[1]~arr[n-1]中取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中取最小值，与arr[2]交换，..., 第i次从arr[i - 1]~arr[n - 1]中取最小值，与arr[i -1]交换，...,第n-1次从arr[n - 2]~arr[n - 1]中取最小值，与arr[n - 2]交换，总共通过n-1次，得到一个按排序码从小到大的有序序列

    3. 说明：

        1. 选择排序一共有数组大小-1轮排序
        2. 每一轮排序，又是一个循环，找到最小数

    4. 代码见：cn.fenqing.arithmetic.sort.SelectSort

8. 插入排序

    1. 介绍
        1. 插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻改元素的适当位置，已达到排序的目的
    2. 思想
        1. 插入排序的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表质保函一个元素，无序表中的包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，吧他的排序码一次与有序表元素的排序码比较，将他插入到有序表的适当位置，使之成为新的有序表
    3. 代码见：cn.fenqing.arithmetic.sort.InsertSort

9. 希尔排序

    1. 简答插入排序存在的问题

        1. 数组arr = {2， 3， 4， 5， 6， 1}，这时需要插入的数1（最小），这样的过程是：

            {2， 3， 4， 5， 6， 6}

            {2， 3， 4， 5， 5， 6}

            {2， 3， 4， 4， 5， 6}

            {2， 3， 3， 4， 5， 6}

            {2， 2， 3， 4， 5， 6}

            {1， 2， 3， 4， 5， 6}

        2. 结论： 当需要插入的数较小的数时，后移的次数明显增多，对效率有影响

    2. 介绍：

        1. 希尔排序是希尔在1959年提出的一种排序算法，希尔排序是一种插入排序，他是简单插入排序经过改进之后的一个更高效的版本，也称之为缩小量排序

    3. 思想：

        1. 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量主键减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰分成一组，算法便终止

        2. 细节
            * 1. 先计算length / 2得到初始组数
            * 2. group >= 1 就对每一组进行插入排序
            * 3. 每一组的对应的值为，i * group，且不可超过数组长度,由于第一位默认为有序，则改成i + group
            * 4. 然后此后以group为步长自增
            * 5. 进行每一组插入排序，只是得按步长的长度来位移
            * 6. 减少分组数量至原先的一半，重复次操作，直到只有一个分组时，并且执行完插入排序后，算法才算完成
    4. 代码见：cn.fenqing.arithmetic.sort.SelectSort
    
10. 快速排序

    1. 介绍
       快速排序对冒泡排序的一种改进，基本思想是:通过一趟排序将要排序的数据分割成独立的两个部分，
       其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对着两部分的数据分别进行快速排序，
       整个排序过程可以递归进行，以此达到整个数据变成有序序列

    2. 思路：

        1. (挖坑法) 从数组中取一个适当的值（中轴），并通过一些手段，让他左边的元素都小于这个值，右边的元素都大于这个值
           1. 实现这一步有两种主流的方法，第一种，挖坑法：
            1. 取数组第一个（start下标）为中轴，将其值保存起来，将0下标视为一个"坑"
            2. 定义两个指针变量，left,right,left从start+1开始，right为end
            3. 从右边开始，向左找，直到找到一个比中轴值小的值，然后将该值赋值给“坑”,然后自己位置变为"坑"
            4. 然后从左边开始，向右找，直到找到一个比中轴大或者等于的值，然后将值赋值给“坑”,然后自己变为"坑"
            5. 反复此步骤，最后将中轴的值给最后坑的位置，即可，坑的位置就是中轴
            6. 代码见：cn.fenqing.arithmetic.sort.QuickSort.findPivotByPothole
        2. (交换法)
            1. 找到一个pivot（基准），low和high（一般pivot选择序列的第一个元素，left为第一个元素，right为最后一个元素）
            2. 向前移动right的位置，直到找到一个比pivot小的元素
            3. 向后移动left的位置，直到找到一个比pivot大的元素
            4. 交换当前的两个元素
            5. 重复2，3，4步位置，直到left>right的时候停止。
            6. 最后直接让right坐标与第一个交换即可（为什么是right：当left>right,则说明right当前的值在交会的时候一定被left检查过，
               是小于pivot的，所以可以将其放在中轴左边）
            7. 代码见：cn.fenqing.arithmetic.sort.QuickSort.findPivotBySwap
    
11. 归并排序
    1. 介绍
        归并排序(MERGE-SORT)是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略(分治法将
       问题分（divide）成一些小的问题，然后递归求解，而治（conquer）的阶段则将分的阶段得到的个答案修补在一起，即分而治之)
       
    2. 思想
        1. 将数组分成两份，再对每一份继续分成2份，直到不能再分（分）
        2. 然后对每一份进行合并（治）
    3. 代码见：cn.fenqing.arithmetic.sort.MergeSort
    

12. 基数排序
    1. 介绍
        1. 基数排序（radix sort） 属于“分配式排序” （distribution sort), 又称“桶子法”，或bin sort，