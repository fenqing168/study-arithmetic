# 栈
1. 实际需求
    1. 输入一个表达式，[7*2*2-5+1-5+3-3]点击计算
    2. 问题: 请问计算器底层是如何运行计算得到结果的？ 注意不是简单的吧算式列出运算，因为我们看到这个算式 7 * 2 * 2 - 5，但是计算机怎么理解这个算式的
    （计算机得到的是一个字符串）我们讨论的是这个问题 -> 栈
       
2. 介绍
    1. 英文: stack
    2. 栈是一个先如后出的有序列表
    3. 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一正龙特殊线性表，允许插入和删除的一段，为变化的一端，
       称之为栈顶，另一端为固定的一段，称之为栈底
       
    4. 根据栈的定义可知，最先放入栈中元素在栈底，最后去放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
    
3. 应用场景

    1. 子程序调用，在调往子程序前，会先将下一个指令的地址存到堆栈中，知道子程序执行玩后再将地址取出，回到原来的程序中
    2. 处理地柜调用，和子程序的调用类型，只是除了存储下一个指令的地址外，也将参数，区域变量，等数据存入堆栈中
    3. 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)
    4. 二叉树的遍历
    5. 图形的深度有限搜索法
   
4. 实现思路
   1. 使用数组模拟栈
      1. 定义一个top表示栈顶，初始化为-1
      2. 入栈的操作，当数据到栈时，top++, stack[top] = data;
      3. 出栈的操作，将数据拿出，top--
      
      4. 代码见: cn.fenqing.datastructures.stack.ArrayStack
   2. 使用链表实现
      1. 定义一个头结点，
      2. 每次添加则从头添加，
      3. 每次删除从尾部删除
      4. 代码见： cn.fenqing.datastructures.stack.LinkedStack
   
5. 实际需求
   1. 输入一个表达式，[7*2*2-5+1-5+3-3]，计算出结果
      1.思路：
         1. 7*2*2-5+1-5+3-4 
         2. 创建两个栈，一个存放数（numStack），一个存放符号(operStack)
         3. 通过一个index值，遍历表达式
         4. 发现是一个数字，就直接入数栈
         5. 如果发现扫描到时一个符号，就分如下情况
            1. 如果发现当前的符号栈为空，就直接入栈
            2. 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，
               就需要从数栈中pop出两个数，再从符号栈中pop一个符号，进行计算，将得到结果，入数栈，
               然后将当前的操作符入符号栈
               
            3. 如果当前的操作符的优先级大于栈中的操作符，将直接入符号栈
         6. 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
         7. 最后在数栈只有一个数字，就是表达式的结果
   2. 前缀，中缀，后缀表达式（逆波兰表达式）
      1. 前缀表达式又称波兰表达式，前缀表达式的运算符位于操作数之前
      2. 举例说明：（3+4）× 5 - 6对应的前缀表达式就是 - x + 3 4 5 6
      3. 前缀表达式的计算机求值，从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数字，用到运算符怼他们最相应的计算
         （栈顶元素和次顶元素），并将结果入栈，重复上述过程知道表达式最左端，最后运算得出的值为表达式的结果
         
      4. 例如:(3+4)*5-6对应的前缀表达式就是 - * + 3 4 5 6，针对前缀表达式求值步骤如下:
         1. 从右至左扫描，将6、5、4、3压入堆栈
         1. 从右至左扫描，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
         2. 接下来是*运算符，因此弹出7和5，计算出7*5=35，将35入栈
         3. 最后是-运算符，计算35-6的值，即29，由此得出最终结果
      5. 中缀表达式就是常见的运算表达式
      6. 中缀表达式的求值是我吗人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转换成其他表达式来操作
      7. 后缀表达式，又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后，
      8. 举例说明，（3 + 4） * 5 - 6对应的后缀表达式就是 3 4 + 5 * 6 -
      
      | 正常表达式 | 逆波兰表达式   |
      | --------- | ------------ |
      | a+b       | a b +        |
      | a+(b-c)   | a b c - +    |
      | a+(b-c)*d | a b c - d * +|
      | a+b*(b-c) | a d b c - * +|
      | a=1+3     | a 1 3 + =    | 
      9. 后缀表达式的计算机求值，从左到右扫描表达式，遇到数字时，想数字压入堆栈，遇到运算符时，翻出栈顶的两个数，用运算符怼他们左相应的计算（次顶元素和栈顶元素）
      并将结果入栈，重复上述过程表达式直到最右端，最后运算得出的值纪委表达式的值
         （3+4）* 5 - 6--> 3 4 + 5 * 6 -
         1. 从左至右扫描，将3和4压入栈
         2. 遇到+运算符因此弹出4 和3（4位栈顶元素，3位次顶元素），计算出3 + 4的值，得7，将7压入栈
         3. 将5压入栈
         4. 接下来是*表达式，因此弹出5和7，计算出7*5=35，将35压入栈
         6. 将6压入栈
         7. 最后是-运算符，计算得出35 - 6，即29 由此得出最终结果
   
   3. 逆波兰表达式
      1. 输入一个逆波兰表达式，使用stack，计算其结果
      2. 代码见： cn.fenqing.datastructures.stack.PolandNotation
   4. 中缀表达式转后缀表达式
      1. 初始化两个栈，运算符栈s1和存储中间结果的栈s2
      2. 从左至右扫描中缀表达式
      3. 遇到操作数时，将其压入s2
      4. 遇到运算符时，比较其余s1栈顶运算符的优先级
         1. 如果s1为空，或栈顶运算符为左括号"("将直接将此运算符入栈
         2. 否则，若优先级比栈顶运算符高，也将运算符压入s1
         3. 否则，将s1栈顶的运算符弹出，并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符比较
      5. 遇到括号是：
         1. 如果是左括号"(" 则直接压入s1
         2. 如果是右括号")" 则依次弹出s1栈顶的运算符，并压入s2,直到遇到左括号为止,此时将这一对括号丢弃
      6. 重复步骤2至5，直到表达式的最右边
      7. 将s1中剩余的运算符依次弹出并压入s2
      8. 依次弹出s2中元素并输出,结果的逆序纪委中缀表达式对应的后缀表达式
      9. 代码见： cn.fenqing.datastructures.stack.PolandNotation.infix2Suffix
   